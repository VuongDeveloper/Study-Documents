1. JPA, Hibernate and Spring Data JPA
*** None of them do create the connection with database, making connection is the work of JDBC
	* JPA
		JPA is a specification for object-relational mapping (ORM) in Java. 
		It defines a set of concepts and APIs for managing relational data in Java applications. 
		JPA itself is not a framework but a set of interfaces and annotations.
		JPQL
	* Hibernate
		Hibernate is an ORM framework that implements the JPA specification but also provides additional features beyond the standard JPA functionality
			. Criteria API and HQL
	* Spring data JPA
		Spring Data JPA is an abstraction layer that sits on top of JPA and ORM providers like Hibernate.
		Introduces the concept of repositories, which are interfaces that provide CRUD operations without the need to write implementations.
		JPQL, HQL, native SQL, or the QueryDSL framework.
		
*** Differences and How They Fit Together
	* Level of Abstraction:
		JPA: 
			Specification level. Defines the standard for ORM in Java.
		Hibernate: 
			Implementation level. Provides a concrete implementation of JPA along with extra features.
		Spring Data JPA: 
			Abstraction and productivity level. Simplifies JPA-based data access with repositories and query methods.
	* Usage:
		JPA: 
			Used when you want to stick to standard APIs and need flexibility to switch between different JPA providers.
		Hibernate: 
			Used when you need advanced ORM features and optimizations provided by Hibernate, either via its native API or as a JPA provider.
		Spring Data JPA: 
			Used in Spring applications to minimize boilerplate code and leverage Spring’s powerful features for dependency injection, transaction management, and more.
	* Configuration and Integration:
		JPA: 
			Can be configured and used with or without Spring. Requires more boilerplate code for setup and operations.
		Hibernate: 
			Can be used standalone or as a JPA provider. Requires configuration but offers more advanced features.
		Spring Data JPA: 
			Requires Spring Framework. Simplifies configuration and reduces boilerplate through conventions and repository interfaces.

2. Specification
	* Purpose: It defines a specification as a predicate over an entity
	* Implementation example:
		* Create class to define Specification for any Entity
		public CustomerSpecifications {
		
		  public static Specification<Customer> customerHasBirthday() {
			return new Specification<Customer> {
			  public Predicate toPredicate(Root<T> root, CriteriaQuery query, CriteriaBuilder cb) {
				return cb.equal(root.get(Customer_.birthday), today);
			  }
			};
		  }

		  public static Specification<Customer> isLongTermCustomer() {
			return new Specification<Customer> {
			  public Predicate toPredicate(Root<T> root, CriteriaQuery query, CriteriaBuilder cb) {
				return cb.lessThan(root.get(Customer_.createdAt), new LocalDate.minusYears(2));
			  }
			};
		  }
		}
		
		*Repository layer
		public interface CustomerRepository extends JpaRepository<Customer>, JpaSpecificationExecutor<Customer> {
		  // Your query methods here
		}
		
3. QueryDSL
	* Requires additional lybraries
	* Purpose: Create BooleanExpression as a predicate for entities without having to create Specification classes
	* Requires: mvn repo of QueryDSL (jpa and apt), besides config in plugin
	
	
4. jOOQ
	* Requires additional lybraries
	* This library generates Java classes based on the database tables and lets us create type-safe SQL queries through its fluent API.
	* https://www.baeldung.com/jooq-intro

	
5. How Hikari connection pooling works?
	a. What is HikariCP?
		. A JDBC DataSource implementation that provides a connection pooling mechanism
		. Compared to other implementations, it promises to be lightweight and better performing.

6. Use UUID for table's primary key
	* References: https://www.baeldung.com/uuid-vs-sequential-id-as-primary-key
	
	* Advantages of Sequential ID (64 bit BIGINT/32 bit INT)
		. Sequential IDs are usually preferred over UUIDs since they require less space -> better performing
		. Easier to read and remember -> easier to track which records are working with
		. Predictable
			-> prefer for Batch job
	* Disavantages of Sequential ID
		. Cannot generate by application, must be calculate by database
		. Incase there are multi instances trying to insert records 
			-> might end up having collisions in our data
				-> need a separate service to compute the next ID
		. Sequential IDs limit their size
		
	* Advantages of using UUID as primary key (128 bit)
		. It's not a big memory problem while UUID using 128bit, just twice bigger than BIGINT used to normal
		. UUID as the primary key can guarantee the collision won’t happen
		-> The main purpose of having UUID as the primary key is the ability to share the data across distributed systems.
		. UUID random is hard to predict -> almost impossible for a malicious user to guess the ID
		. UUID is that it can be generated by the application or the database system itself.
		. No need to worry about the next value of id like Auto Increment system
	* Disavantages of UUID
		. Hard to read and remember, but do we need to remember a primay key?
		. Can’t sort the UUID values in the natural order
		. UUID values don’t index well. 
			? The longer the key, the more memory the index entry will require.
			? as UUID is generated randomly -> everytime a new records is inserted, system needs to redo to indexing
===>	When to use?
	. UUID			: better for NoSQL and distributed database
	. Sequential ID	: better for relational database, and not distributed database